[
    {
        "title": "Background Information",
        "text": [
            "#### Perlin Noise",
            "##### > History",
            "Perlin noise is a form of gradient noise that was developed by",
            "Ken Perlin. He later goes on to develop Simplex noise which",
            "solves some of the problems that arise in Perlin noise, which was",
            "released under copyright. Several implementations of Simplex",
            "noise that sidestep the copyright can be found such as",
            "[OpenSimplex](https://github.com/lmas/opensimplex).",

            "##### > Noise Generation Overview",
            "Ken Perlin defines a 256 long array `p` filled with a permutation",
            "of all the numbers from 0 to 255. Changing the permutation of",
            "this array is one way to seed the noise function to produce a",
            "different set of deterministic outputs.\n",

            "For each input point, the point is normalized to a unit grid cell",
            "modded to a 256<sup>n</sup> grid. This 256 corresponds with the",
            "length of the array `p` and the `n` is the dimensionality of the",
            "Perlin noise generated. As a result, Perlin noise wraps every 256",
            "units in any direction. Each of the corners of the grid cell is",
            "assigned a gradient vector with are later linearly interpolated",
            "based on the position of the point in the grid cell to calculate",
            "the final noise value.\n",

            "##### > Calculation of Gradient Vectors",
            "These gradient vectors are calculated by first accessing the",
            "array `p` to compute a hash `h` using the each of the",
            "coordinates:\n",
            "```python",
            "def hash(x):",
            "    return p[x[n] + p[x[n-1] + p[ ... + p[x[0]]]]]",
            "```\n",

            "This can be easily extended into higher dimensions by adding",
            "indexing additional times for each dimension.\n",

            "Next, each of the coordinates `x[i]` are smoothed out with",
            "Perlin's fade function defined as:\n",
            "```python",
            "def fade(t):",
            "    return t * t * t * (t * (t * 6 - 15) + 10)",
            "```\n",
            "which is just equivalent to ",
            "fade(t) = 6t<sup>5</sup> - 15t<sup>4</sup> + 10t<sup>3</sup>.\n",

            "The hash `h` and smoothed coordinates are then used to generate",
            "the gradient vector by mapping to the 12 diagonal vectors aligned",
            "to a plane.\n",

            "Perlin mapped the lower 4 bits (16 total values) to these 12",
            "vectors, which does result in 4 of the vectors being twice as",
            "likely to be selected.\n",

            "Perlin's gradient function is as follows:\n",
            "```python",
            "def grad(h, x, y, z):",
            "    # Grab the lower 4 bits",
            "    h = h & 15",
            "    # Choose 2 directions",
            "    u = x if h < 8 else y",
            "    v = x if h == 12 or h == 14 else z",
            "    # Change sign of directions with lower 2 bits",
            "    return (u if h & 1 else -u) + (v if h & 2 else -v)",
            "```\n",

            "A different hash function would have to be used for dimensions",
            "other greater than or less than 3. An equal distribution of",
            "gradient vectors would be ideal.\n",

            "##### > The Final Noise Value",
            "The contribution of the each of the corner is the sum of the",
            "components of the gradient vector at that corner. This value is",
            "then combined by linearly interpolating over each of the axes to",
            "compute the final noise value. A common additional step is to",
            "normalize from [-1,1] to [0,1]."
        ]
    }, 
    {   
        "title": "What I Accomplished",
        "text": [
            "#### Features",
            "- Implement 3D Perlin Noise\n",
            "- Generate an icosphere by subdividing an icosahedron\n",
            "- Generate heightmaps with 3D Perlin Noise\n",
            "- Generate clouds\n",
            "- Generate heatmap and moisture map to recolor based on",
            "'biomes'\n",
            "- Keyboard Controls\n",

            "#### Implementation Details",
            "##### > 3D Perlin Noise",
            "The 3D Perlin Noise is implemented as described above, with a",
            "minor change to the gradient function that increases human",
            "comprehension of the function by unrolling all the bit operations",
            "into a single switch statement that maps the hash value to the",
            "gradient vector sum.",

            "##### > Generate an Icosphere",
            "Rather than using a standard latitude/longitude discretization of",
            "the planet, a equidistant discretization was used instead. The",
            "former would result in a larger number of triangles present in",
            "poles whereas the latter ensures the distribution of triangles",
            "remains constant throughout the sphere.\n",

            "This sphere was generated from an icosahedron. The icosahedron is",
            "constantly subdivided where each edge is bisected to generate",
            "four new triangles from the original. The midpoints of the edges",
            "are normalized to the unit sphere so as to incrementally produce",
            "the sphere.",

            "##### > Generate Heightmap",
            "To generate the heightmap, each point on the icosphere is sampled",
            "using the Perlin noise function. 3D noise is necessary here",
            "because it allows for coherent wrapping around the sphere. 2D",
            "noise could have been used and projected on the sphere, but since",
            "there is no perfect 2D plane to spherical surface projection",
            "without distortions, sampling 3D noise produces simpler and more",
            "aesthetically pleasing results.\n",

            "The sampled noise is then scaled to a desired range [-a,a] for",
            "some chosen parameter a and the vertex is scaled to the radius",
            "plus this noise value.",

            "##### > Generate Heat and Moisture Maps",
            "To generate the moisture map, each point on the icosphere is",
            "sampled using the Perlin noise function like the heightmap.\n",
            "To generate the heat map, each point is sampled and the resulting",
            "value is biased based on the current latitude. Since the planet",
            "rotates around the vertical y-axis, the latitude is simply the",
            "y-coordinate. This is done since areas near the equator are",
            "hotter than those towards the poles.",

            "##### > Color Based on Height, Heat, and Moisture",
            "Anything below the planet radius becomes ocean and all the other",
            "regions are up for consideration of a biome. The biomes used are",
            "borrowed from the planet generation article listed below. The",
            "colors used are:\n",
            "![Biome Colors](http://www.jgallant.com/wp-content/uploads/2016/01/biomecolors.jpg 'Biome Colors')\n",
            "To decide which biome each point is, the following discretization",
            "was used:\n",
            "![Biome Discretization](http://www.jgallant.com/wp-content/uploads/2016/01/biometable.jpg 'Biome Discretization')\n",
            "By default, each of the columns and rows are equally spaced.",

            "##### > Generate Clouds",
            "To generate clouds, a larger icosphere is generated around the",
            "planet. The points on this sphere are then sampled using the",
            "Perlin noise function and noise values above a certain threshold",
            "are clouds and the noise value itself is used as the opacity of",
            "the clouds to make it more aesthetically pleasing.",

            "##### > Keyboard Controls",
            "Several different keyboard controls were added to allow for",
            "fiddling with the generated planet. In particular, changing the",
            "rotation axis and the water level provides the most immediate",
            "results. The planet redesignates what is ocean with changes to",
            "the sea level. The rotation axis defines the equator of the",
            "planet, so the heat map changes freely with rotation axis. In",
            "addition, since the ocean regions are now affecting moisture, the",
            "moisture map does change now with the sea level; however, it only",
            "changes the moisture of the ocean regions which does not affect",
            "biomes in any way.\n",
            
            "The keyboard controls are as follows:\n",
            "| Key   | Action                  |",
            "| ----- | ----------------------- |",
            "| 1     | Swap to Line Mode       |",
            "| 2     | Swap to Fill Mode       |",
            "| 3     | Render Planet Mode      |",
            "| 4     | Render Heat Mode        |",
            "| 5     | Render Moisture Mode    |",
            "| Left  | Rotate Axis Left        |",
            "| Right | Rotate Axis Right       |",
            "| Up    | Increase # Subdivisions |",
            "| Down  | Decrease # Subdivisions |",
            "| R     | Generate New Seed       |",
            "| W     | Increase Water Level    |",
            "| S     | Decrease Water Level    |",
            "| P     | Pause/Continue Rotation |",
            "| Q     | Zoom Out                |",
            "| E     | Zoom In                 |\n"
        ]
    },
    {
        "title": "Artifacts",
        "text": [
            "#### Generated Planets",
            "##### > Default Planet",
            "![Planet 1](/static/media/planet1.gif 'Planet 1')\n",
            "##### > Mostly Water Planet",
            "![Planet 2](/static/media/planet2.gif 'Planet 2')\n",
            "##### > Mostly Land Planet",
            "![Planet 3](/static/media/planet3.gif 'Planet 3')\n"
        ]
    },
    {
        "title": "References",
        "text": [
            "#### Perlin Noise",
            "- [Explanation/Implementation of Algorithm](http://flafla2.github.io/2014/08/09/perlinnoise.html)\n",
            "- [Ken Perlin's Reference Implementation](http://mrl.nyu.edu/~perlin/noise/)\n",
			"- [Ken Perlin's Improved Noise Paper](http://mrl.nyu.edu/~perlin/paper445.pdf)\n",

            "#### Planet Generation",
            "- [Biome Coloration](http://www.jgallant.com/procedurally-generating-wrapping-world-maps-in-unity-csharp-part-4/#biomes)\n",

            "#### Icosphere Generation",
            "- [Baseline Icosahedron Vertices/Triangles](https://schneide.wordpress.com/2016/07/15/generating-an-icosphere-in-c/)\n"
        ]
    }
]
